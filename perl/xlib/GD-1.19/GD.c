/*
 * This file was generated automatically by xsubpp version 1.9508 from the 
 * contents of GD.xs. Do not edit this file, edit GD.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "GD.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "libgd/gd.h"
#ifdef FCGI
 #include <fcgi_stdio.h>
#else
 #ifdef USE_SFIO
  #include <config.h>
 #else
  #include <stdio.h>
 #endif
 #include <perlio.h>
#endif
/* Copyright 1995 - 1998, Lincoln D. Stein.  See accompanying README file for
	usage restrictions */

static int
not_here(s)
char *s;
{
    croak("%s not implemented on this architecture", s);
    return -1;
}

static double
constant(name, arg)
char *name;
int arg;
{
    errno = 0;
    switch (*name) {
    case 'A':
	break;
    case 'B':
	break;
    case 'C':
	break;
    case 'D':
	break;
    case 'E':
	break;
    case 'F':
	break;
    case 'G':
	break;
    case 'H':
	break;
    case 'I':
	break;
    case 'J':
	break;
    case 'K':
	break;
    case 'L':
	break;
    case 'M':
	break;
    case 'N':
	break;
    case 'O':
	break;
    case 'P':
	break;
    case 'Q':
	break;
    case 'R':
	break;
    case 'S':
	break;
    case 'T':
	break;
    case 'U':
	break;
    case 'V':
	break;
    case 'W':
	break;
    case 'X':
	break;
    case 'Y':
	break;
    case 'Z':
	break;
    case 'a':
	break;
    case 'b':
	break;
    case 'c':
	break;
    case 'd':
	break;
    case 'e':
	break;
    case 'f':
	break;
    case 'g':
	if (strEQ(name, "gdBrushed"))
#ifdef gdBrushed
	    return gdBrushed;
#else
	    goto not_there;
#endif
	if (strEQ(name, "gdDashSize"))
#ifdef gdDashSize
	    return gdDashSize;
#else
	    goto not_there;
#endif
	if (strEQ(name, "gdMaxColors"))
#ifdef gdMaxColors
	    return gdMaxColors;
#else
	    goto not_there;
#endif
	if (strEQ(name, "gdStyled"))
#ifdef gdStyled
	    return gdStyled;
#else
	    goto not_there;
#endif
	if (strEQ(name, "gdStyledBrushed"))
#ifdef gdStyledBrushed
	    return gdStyledBrushed;
#else
	    goto not_there;
#endif
	if (strEQ(name, "gdTiled"))
#ifdef gdTiled
	    return gdTiled;
#else
	    goto not_there;
#endif
	if (strEQ(name, "gdTransparent"))
#ifdef gdTransparent
	    return gdTransparent;
#else
	    goto not_there;
#endif
	break;
    case 'h':
	break;
    case 'i':
	break;
    case 'j':
	break;
    case 'k':
	break;
    case 'l':
	break;
    case 'm':
	break;
    case 'n':
	break;
    case 'o':
	break;
    case 'p':
	break;
    case 'q':
	break;
    case 'r':
	break;
    case 's':
	break;
    case 't':
	break;
    case 'u':
	break;
    case 'v':
	break;
    case 'w':
	break;
    case 'x':
	break;
    case 'y':
	break;
    case 'z':
	break;
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}

typedef gdImagePtr	GD__Image;
typedef gdFontPtr	GD__Font;
typedef PerlIO * InputStream;
extern 	gdFontPtr	gdFontGiant;
extern 	gdFontPtr	gdFontLarge;
extern	gdFontPtr	gdFontSmall;
extern	gdFontPtr	gdFontMediumBold;
extern	gdFontPtr	gdFontTiny;

#line 207 "GD.c"
XS(XS_GD_constant)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: GD::constant(name, arg)");
    {
	char *	name = (char *)SvPV(ST(0),PL_na);
	int	arg = (int)SvIV(ST(1));
	double	RETVAL;
	dXSTARG;

	RETVAL = constant(name, arg);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_new)
{
    dXSARGS;
    if (items < 0 || items > 3)
	Perl_croak(aTHX_ "Usage: GD::Image::new(packname=\"GD::Image\", x=64, y=64)");
    {
	char *	packname;
	int	x;
	int	y;
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}

	if (items < 2)
	    x = 64;
	else {
	    x = (int)SvIV(ST(1));
	}

	if (items < 3)
	    y = 64;
	else {
	    y = (int)SvIV(ST(2));
	}
#line 213 "GD.xs"
	{
		gdImagePtr theImage;
		theImage = gdImageCreate(x,y);
		RETVAL = theImage;
	}
#line 259 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image__newFromGif)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::_newFromGif(packname=\"GD::Image\", filehandle)");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)));
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 227 "GD.xs"
	RETVAL = gdImageCreateFromGif(filehandle);
#line 283 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image__newFromXbm)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::_newFromXbm(packname=\"GD::Image\", filehandle)");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)));
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 237 "GD.xs"
	RETVAL = gdImageCreateFromXbm(filehandle);
#line 307 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image__newFromGd)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::_newFromGd(packname=\"GD::Image\", filehandle)");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)));
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 247 "GD.xs"
	RETVAL = gdImageCreateFromGd(filehandle);
#line 331 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Image::DESTROY(image)");
    {
	GD__Image	image;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not a reference");
#line 257 "GD.xs"
	{
		gdImageDestroy(image);
	}
#line 356 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_gif)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Image::gif(image)");
    {
	GD__Image	image;
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 266 "GD.xs"
  {
	void*         data;
	int           size;
	data = gdImageGifPtr(image,&size);
	RETVAL = newSVpv((char*) data,size);
	free(data);
  }
#line 384 "GD.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_GD__Image_gd)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Image::gd(image)");
    {
	GD__Image	image;
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 281 "GD.xs"
  {
	void*         data;
	int           size;
	data = gdImageGdPtr(image,&size);
	RETVAL = newSVpv((char*) data,size);
	free(data);
  }
#line 414 "GD.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_GD__Image_transparent)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: GD::Image::transparent(image, ...)");
    {
	GD__Image	image;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 296 "GD.xs"
	{
		int color;
		if (items > 1) {
			color=(int)SvIV(ST(1));
			gdImageColorTransparent(image,color);
		}
		RETVAL = gdImageGetTransparent(image);
	}
#line 446 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_getBounds)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Image::getBounds(image)");
    SP -= items;
    {
	GD__Image	image;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 312 "GD.xs"
	{
		int sx,sy;
		sx = gdImageSX(image);
		sy = gdImageSY(image);
		EXTEND(sp,2);
		PUSHs(sv_2mortal(newSViv(sx)));
		PUSHs(sv_2mortal(newSViv(sy)));
	}
#line 476 "GD.c"
	PUTBACK;
	return;
    }
}

XS(XS_GD__Image_rgb)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: GD::Image::rgb(image, color)");
    SP -= items;
    {
	GD__Image	image;
	int	color = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 327 "GD.xs"
	{
		int r,g,b;
		r = gdImageRed(image,color);
		g = gdImageGreen(image,color);
		b = gdImageBlue(image,color);
		EXTEND(sp,3);
		PUSHs(sv_2mortal(newSViv(r)));
		PUSHs(sv_2mortal(newSViv(g)));
		PUSHs(sv_2mortal(newSViv(b)));
	}
#line 511 "GD.c"
	PUTBACK;
	return;
    }
}

XS(XS_GD__Image_boundsSafe)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: GD::Image::boundsSafe(image, x, y)");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1));
	int	y = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 345 "GD.xs"
	{
		RETVAL=gdImageBoundsSafe(image,x,y);
	}
#line 539 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_getPixel)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: GD::Image::getPixel(image, x, y)");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1));
	int	y = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 358 "GD.xs"
	{
		RETVAL=gdImageGetPixel(image,x,y);
	}
#line 567 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_setPixel)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: GD::Image::setPixel(image, x, y, color)");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1));
	int	y = (int)SvIV(ST(2));
	int	color = (int)SvIV(ST(3));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 372 "GD.xs"
	{
		gdImageSetPixel(image,x,y,color);
	}
#line 594 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_line)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::line(image, x1, y1, x2, y2, color)");
    {
	GD__Image	image;
	int	x1 = (int)SvIV(ST(1));
	int	y1 = (int)SvIV(ST(2));
	int	x2 = (int)SvIV(ST(3));
	int	y2 = (int)SvIV(ST(4));
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 386 "GD.xs"
	{
		gdImageLine(image,x1,y1,x2,y2,color);
	}
#line 622 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_dashedLine)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::dashedLine(image, x1, y1, x2, y2, color)");
    {
	GD__Image	image;
	int	x1 = (int)SvIV(ST(1));
	int	y1 = (int)SvIV(ST(2));
	int	x2 = (int)SvIV(ST(3));
	int	y2 = (int)SvIV(ST(4));
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 400 "GD.xs"
	{
		gdImageDashedLine(image,x1,y1,x2,y2,color);
	}
#line 650 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_openPolygon)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: GD::Image::openPolygon(image, poly, color)");
    {
	GD__Image	image;
	SV *	poly = ST(1);
	int	color = (int)SvIV(ST(2));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 411 "GD.xs"
	{
		dSP ;
		int length,count ;
		int x,y,i ;
		gdPointPtr polyptr;

		ENTER ;
		SAVETMPS ;
		PUSHMARK(sp) ;
		XPUSHs(poly) ;
		PUTBACK ;
		count = perl_call_method("length",G_SCALAR) ;
		SPAGAIN ;
		if (count != 1)
			croak("Didn't get a single result from GD::Poly::length() call.\n");
		length = POPi ;
		PUTBACK ;
		FREETMPS ;
		LEAVE ;

		polyptr = (gdPointPtr)safemalloc(sizeof(gdPoint)*length);
		if (polyptr == NULL)
			croak("safemalloc() returned NULL in GD::Image::poly().\n");

		for (i=0;i<length;i++) {
			ENTER ;
			SAVETMPS ;
			PUSHMARK(sp) ;
			XPUSHs(poly) ;
			XPUSHs(sv_2mortal(newSViv(i))) ;
			PUTBACK ;
			count = perl_call_method("getPt",G_ARRAY) ;
			SPAGAIN ;
			if (count != 2)
				croak("Didn't get a single result from GD::Poly::length() call.\n");
			y = POPi ;
			x = POPi ;
			PUTBACK ;
			FREETMPS ;
			LEAVE ;

			polyptr[i].x = x;
			polyptr[i].y = y;
		}

		gdImageOpenPolygon(image,polyptr,length,color);
		safefree((char*) polyptr);
	}
#line 720 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_filledPolygon)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: GD::Image::filledPolygon(image, poly, color)");
    {
	GD__Image	image;
	SV *	poly = ST(1);
	int	color = (int)SvIV(ST(2));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 467 "GD.xs"
	{
		dSP ;
		int length,count ;
		int x,y,i ;
		gdPointPtr polyptr;

		ENTER ;
		SAVETMPS ;
		PUSHMARK(sp) ;
		XPUSHs(poly) ;
		PUTBACK ;
		count = perl_call_method("length",G_SCALAR) ;
		SPAGAIN ;
		if (count != 1)
			croak("Didn't get a single result from GD::Poly::length() call.\n");
		length = POPi ;
		PUTBACK ;
		FREETMPS ;
		LEAVE ;

		polyptr = (gdPointPtr)safemalloc(sizeof(gdPoint)*length);
		if (polyptr == NULL)
			croak("safemalloc() returned NULL in GD::Image::poly().\n");

		for (i=0;i<length;i++) {
			ENTER ;
			SAVETMPS ;
			PUSHMARK(sp) ;
			XPUSHs(poly) ;
			XPUSHs(sv_2mortal(newSViv(i))) ;
			PUTBACK ;
			count = perl_call_method("getPt",G_ARRAY) ;
			SPAGAIN ;
			if (count != 2)
				croak("Didn't get a single result from GD::Poly::length() call.\n");
			y = POPi ;
			x = POPi ;
			PUTBACK ;
			FREETMPS ;
			LEAVE ;

			polyptr[i].x = x;
			polyptr[i].y = y;
		}

		gdImageFilledPolygon(image,polyptr,length,color);
		safefree((char*) polyptr);
	}
#line 790 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_rectangle)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::rectangle(image, x1, y1, x2, y2, color)");
    {
	GD__Image	image;
	int	x1 = (int)SvIV(ST(1));
	int	y1 = (int)SvIV(ST(2));
	int	x2 = (int)SvIV(ST(3));
	int	y2 = (int)SvIV(ST(4));
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 526 "GD.xs"
	{
		gdImageRectangle(image,x1,y1,x2,y2,color);
	}
#line 818 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_filledRectangle)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::filledRectangle(image, x1, y1, x2, y2, color)");
    {
	GD__Image	image;
	int	x1 = (int)SvIV(ST(1));
	int	y1 = (int)SvIV(ST(2));
	int	x2 = (int)SvIV(ST(3));
	int	y2 = (int)SvIV(ST(4));
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 540 "GD.xs"
	{
		gdImageFilledRectangle(image,x1,y1,x2,y2,color);
	}
#line 846 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_arc)
{
    dXSARGS;
    if (items != 8)
	Perl_croak(aTHX_ "Usage: GD::Image::arc(image, cx, cy, w, h, s, e, color)");
    {
	GD__Image	image;
	int	cx = (int)SvIV(ST(1));
	int	cy = (int)SvIV(ST(2));
	int	w = (int)SvIV(ST(3));
	int	h = (int)SvIV(ST(4));
	int	s = (int)SvIV(ST(5));
	int	e = (int)SvIV(ST(6));
	int	color = (int)SvIV(ST(7));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 556 "GD.xs"
	{
		gdImageArc(image,cx,cy,w,h,s,e,color);
	}
#line 876 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_fillToBorder)
{
    dXSARGS;
    if (items != 5)
	Perl_croak(aTHX_ "Usage: GD::Image::fillToBorder(image, x, y, border, color)");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1));
	int	y = (int)SvIV(ST(2));
	int	border = (int)SvIV(ST(3));
	int	color = (int)SvIV(ST(4));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 569 "GD.xs"
	{
		gdImageFillToBorder(image,x,y,border,color);
	}
#line 903 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_fill)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: GD::Image::fill(image, x, y, color)");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1));
	int	y = (int)SvIV(ST(2));
	int	color = (int)SvIV(ST(3));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 581 "GD.xs"
	{
		gdImageFill(image,x,y,color);
	}
#line 929 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_setBrush)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: GD::Image::setBrush(image, brush)");
    {
	GD__Image	image;
	GD__Image	brush;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    brush = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("brush is not of type GD::Image");
#line 591 "GD.xs"
	{
		gdImageSetBrush(image,brush);
	}
#line 960 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_setTile)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: GD::Image::setTile(image, tile)");
    {
	GD__Image	image;
	GD__Image	tile;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    tile = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("tile is not of type GD::Image");
#line 601 "GD.xs"
	{
		gdImageSetTile(image,tile);
	}
#line 991 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_setStyle)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: GD::Image::setStyle(image, ...)");
    {
	GD__Image	image;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 610 "GD.xs"
	{
		int	*style;
		int	i;

		if (items < 2)
			return;
		style = (int*) safemalloc(sizeof(int)*(items-1));
		if (style == NULL)
			croak("malloc returned NULL at setStyle().\n");
		for(i=1;i<items;i++) {
			style[i-1]=(int)SvIV(ST(i));
		}
		gdImageSetStyle(image,style,items-1);
		safefree((char*) style);
	}
#line 1026 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_colorAllocate)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: GD::Image::colorAllocate(image, r, g, b)");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1));
	int	g = (int)SvIV(ST(2));
	int	b = (int)SvIV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 634 "GD.xs"
	{
		RETVAL = gdImageColorAllocate(image,r,g,b);
	}
#line 1054 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_colorClosest)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: GD::Image::colorClosest(image, r, g, b)");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1));
	int	g = (int)SvIV(ST(2));
	int	b = (int)SvIV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 648 "GD.xs"
	{
		RETVAL = gdImageColorClosest(image,r,g,b);
	}
#line 1083 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_colorExact)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: GD::Image::colorExact(image, r, g, b)");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1));
	int	g = (int)SvIV(ST(2));
	int	b = (int)SvIV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 662 "GD.xs"
	{
		RETVAL = gdImageColorExact(image,r,g,b);
	}
#line 1112 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_colorsTotal)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Image::colorsTotal(image)");
    {
	GD__Image	image;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 673 "GD.xs"
	{
		RETVAL = gdImageColorsTotal(image);
	}
#line 1138 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_interlaced)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: GD::Image::interlaced(image, ...)");
    {
	GD__Image	image;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 685 "GD.xs"
	{
		if (items > 1) {
			if (SvOK(ST(1)))
				gdImageInterlace(image,1);
			else
				gdImageInterlace(image,0);
		}
		RETVAL = gdImageGetInterlaced(image);
	}
#line 1170 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_colorDeallocate)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: GD::Image::colorDeallocate(image, color)");
    {
	GD__Image	image;
	int	color = (int)SvIV(ST(1));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 703 "GD.xs"
	{
		gdImageColorDeallocate(image,color);
	}
#line 1195 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_copy)
{
    dXSARGS;
    if (items != 8)
	Perl_croak(aTHX_ "Usage: GD::Image::copy(destination, source, dstX, dstY, srcX, srcY, w, h)");
    {
	GD__Image	destination;
	GD__Image	source;
	int	dstX = (int)SvIV(ST(2));
	int	dstY = (int)SvIV(ST(3));
	int	srcX = (int)SvIV(ST(4));
	int	srcY = (int)SvIV(ST(5));
	int	w = (int)SvIV(ST(6));
	int	h = (int)SvIV(ST(7));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    destination = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("destination is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    source = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("source is not of type GD::Image");
#line 719 "GD.xs"
	{
		gdImageCopy(destination,source,dstX,dstY,srcX,srcY,w,h);
	}
#line 1232 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_copyResized)
{
    dXSARGS;
    if (items != 10)
	Perl_croak(aTHX_ "Usage: GD::Image::copyResized(destination, source, dstX, dstY, srcX, srcY, destW, destH, srcW, srcH)");
    {
	GD__Image	destination;
	GD__Image	source;
	int	dstX = (int)SvIV(ST(2));
	int	dstY = (int)SvIV(ST(3));
	int	srcX = (int)SvIV(ST(4));
	int	srcY = (int)SvIV(ST(5));
	int	destW = (int)SvIV(ST(6));
	int	destH = (int)SvIV(ST(7));
	int	srcW = (int)SvIV(ST(8));
	int	srcH = (int)SvIV(ST(9));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    destination = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("destination is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    source = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("source is not of type GD::Image");
#line 737 "GD.xs"
	{
		gdImageCopyResized(destination,source,dstX,dstY,srcX,srcY,destW,destH,srcW,srcH);
	}
#line 1271 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_char)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::char(image, font, x, y, c, color)");
    {
	GD__Image	image;
	GD__Font	font;
	int	x = (int)SvIV(ST(2));
	int	y = (int)SvIV(ST(3));
	char *	c = (char *)SvPV(ST(4),PL_na);
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 751 "GD.xs"
	{
		gdImageChar(image,font,x,y,*c,color);
	}
#line 1306 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_charUp)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::charUp(image, font, x, y, c, color)");
    {
	GD__Image	image;
	GD__Font	font;
	int	x = (int)SvIV(ST(2));
	int	y = (int)SvIV(ST(3));
	char *	c = (char *)SvPV(ST(4),PL_na);
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 765 "GD.xs"
	{
		gdImageCharUp(image,font,x,y,*c,color);
	}
#line 1341 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_string)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::string(image, font, x, y, s, color)");
    {
	GD__Image	image;
	GD__Font	font;
	int	x = (int)SvIV(ST(2));
	int	y = (int)SvIV(ST(3));
	char *	s = (char *)SvPV(ST(4),PL_na);
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 779 "GD.xs"
	{
		gdImageString(image,font,x,y,s,color);
	}
#line 1376 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_stringUp)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::stringUp(image, font, x, y, s, color)");
    {
	GD__Image	image;
	GD__Font	font;
	int	x = (int)SvIV(ST(2));
	int	y = (int)SvIV(ST(3));
	char *	s = (char *)SvPV(ST(4),PL_na);
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 793 "GD.xs"
	{
		gdImageStringUp(image,font,x,y,s,color);
	}
#line 1411 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Font_Small)
{
    dXSARGS;
    if (items < 0 || items > 1)
	Perl_croak(aTHX_ "Usage: GD::Font::Small(packname=\"GD::Font\")");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 804 "GD.xs"
	{
		RETVAL = gdFontSmall;
	}
#line 1434 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Font", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_Large)
{
    dXSARGS;
    if (items < 0 || items > 1)
	Perl_croak(aTHX_ "Usage: GD::Font::Large(packname=\"GD::Font\")");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 815 "GD.xs"
	{
		RETVAL = gdFontLarge;
	}
#line 1459 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Font", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_Giant)
{
    dXSARGS;
    if (items < 0 || items > 1)
	Perl_croak(aTHX_ "Usage: GD::Font::Giant(packname=\"GD::Font\")");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 826 "GD.xs"
	{
		RETVAL = gdFontGiant;
	}
#line 1484 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Font", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_MediumBold)
{
    dXSARGS;
    if (items < 0 || items > 1)
	Perl_croak(aTHX_ "Usage: GD::Font::MediumBold(packname=\"GD::Font\")");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 837 "GD.xs"
	{
		RETVAL = gdFontMediumBold;
	}
#line 1509 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Font", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_Tiny)
{
    dXSARGS;
    if (items < 0 || items > 1)
	Perl_croak(aTHX_ "Usage: GD::Font::Tiny(packname=\"GD::Font\")");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 848 "GD.xs"
	{
		RETVAL = gdFontTiny;
	}
#line 1534 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Font", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_nchars)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Font::nchars(font)");
    {
	GD__Font	font;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 859 "GD.xs"
	{
		RETVAL = font->nchars;
	}
#line 1561 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_offset)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Font::offset(font)");
    {
	GD__Font	font;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 870 "GD.xs"
	{
		RETVAL = font->offset;
	}
#line 1587 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_width)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Font::width(font)");
    {
	GD__Font	font;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 881 "GD.xs"
	{
		RETVAL = font->w;
	}
#line 1613 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_height)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Font::height(font)");
    {
	GD__Font	font;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 892 "GD.xs"
	{
		RETVAL = font->h;
	}
#line 1639 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_GD)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("GD::constant", XS_GD_constant, file);
        newXSproto("GD::Image::new", XS_GD__Image_new, file, "$;$$");
        newXSproto("GD::Image::_newFromGif", XS_GD__Image__newFromGif, file, "$$");
        newXSproto("GD::Image::_newFromXbm", XS_GD__Image__newFromXbm, file, "$$");
        newXSproto("GD::Image::_newFromGd", XS_GD__Image__newFromGd, file, "$$");
        newXSproto("GD::Image::DESTROY", XS_GD__Image_DESTROY, file, "$");
        newXSproto("GD::Image::gif", XS_GD__Image_gif, file, "$");
        newXSproto("GD::Image::gd", XS_GD__Image_gd, file, "$");
        newXSproto("GD::Image::transparent", XS_GD__Image_transparent, file, "$;$");
        newXSproto("GD::Image::getBounds", XS_GD__Image_getBounds, file, "$");
        newXSproto("GD::Image::rgb", XS_GD__Image_rgb, file, "$$");
        newXSproto("GD::Image::boundsSafe", XS_GD__Image_boundsSafe, file, "$$$");
        newXSproto("GD::Image::getPixel", XS_GD__Image_getPixel, file, "$$$");
        newXSproto("GD::Image::setPixel", XS_GD__Image_setPixel, file, "$$$");
        newXSproto("GD::Image::line", XS_GD__Image_line, file, "$$$$$$");
        newXSproto("GD::Image::dashedLine", XS_GD__Image_dashedLine, file, "$$$$$$");
        newXSproto("GD::Image::openPolygon", XS_GD__Image_openPolygon, file, "$$$");
        newXSproto("GD::Image::filledPolygon", XS_GD__Image_filledPolygon, file, "$$$");
        newXSproto("GD::Image::rectangle", XS_GD__Image_rectangle, file, "$$$$$$");
        newXSproto("GD::Image::filledRectangle", XS_GD__Image_filledRectangle, file, "$$$$$$");
        newXSproto("GD::Image::arc", XS_GD__Image_arc, file, "$$$$$$$$");
        newXSproto("GD::Image::fillToBorder", XS_GD__Image_fillToBorder, file, "$$$$$");
        newXSproto("GD::Image::fill", XS_GD__Image_fill, file, "$$$$");
        newXSproto("GD::Image::setBrush", XS_GD__Image_setBrush, file, "$$");
        newXSproto("GD::Image::setTile", XS_GD__Image_setTile, file, "$$");
        newXSproto("GD::Image::setStyle", XS_GD__Image_setStyle, file, "$;$");
        newXSproto("GD::Image::colorAllocate", XS_GD__Image_colorAllocate, file, "$$$$");
        newXSproto("GD::Image::colorClosest", XS_GD__Image_colorClosest, file, "$$$$");
        newXSproto("GD::Image::colorExact", XS_GD__Image_colorExact, file, "$$$$");
        newXSproto("GD::Image::colorsTotal", XS_GD__Image_colorsTotal, file, "$");
        newXSproto("GD::Image::interlaced", XS_GD__Image_interlaced, file, "$;$");
        newXSproto("GD::Image::colorDeallocate", XS_GD__Image_colorDeallocate, file, "$$");
        newXSproto("GD::Image::copy", XS_GD__Image_copy, file, "$$$$$$$$");
        newXSproto("GD::Image::copyResized", XS_GD__Image_copyResized, file, "$$$$$$$$$$");
        newXSproto("GD::Image::char", XS_GD__Image_char, file, "$$$$$$");
        newXSproto("GD::Image::charUp", XS_GD__Image_charUp, file, "$$$$$$");
        newXSproto("GD::Image::string", XS_GD__Image_string, file, "$$$$$$");
        newXSproto("GD::Image::stringUp", XS_GD__Image_stringUp, file, "$$$$$$");
        newXSproto("GD::Font::Small", XS_GD__Font_Small, file, "$");
        newXSproto("GD::Font::Large", XS_GD__Font_Large, file, "$");
        newXSproto("GD::Font::Giant", XS_GD__Font_Giant, file, "$");
        newXSproto("GD::Font::MediumBold", XS_GD__Font_MediumBold, file, "$");
        newXSproto("GD::Font::Tiny", XS_GD__Font_Tiny, file, "$");
        newXSproto("GD::Font::nchars", XS_GD__Font_nchars, file, "$");
        newXSproto("GD::Font::offset", XS_GD__Font_offset, file, "$");
        newXSproto("GD::Font::width", XS_GD__Font_width, file, "$");
        newXSproto("GD::Font::height", XS_GD__Font_height, file, "$");
    XSRETURN_YES;
}

